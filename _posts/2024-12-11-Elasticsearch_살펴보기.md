---
title: ElasticSearch Essential - 02 살펴보기
description: >-
  elasticsearch 대해 정확하게 알기 위해 <kbd>ElasticSearch Essential(강진우)</kbd>강의를 들으며 공부한 내용을 정리
author: ggong
date: 2024-12-11 08:45:00 +0800
categories: [online-course, elasticSearch]
tags: [online-course, inflean, elasticSearch, study]
pin: true
media_subpath: '/assets/img/elasticsearch'
---


> 주요 내용 : 클러스터, 노드, 인덱스, 샤드, 매핑에 대한 이해
{: .prompt-info }

## Elasticsearch 소개
**설명**
: 루씬(Lucene) 기반의 오픈소스 검색 엔진, 라이브러리를 이용해 만들어진 거대 애플리케이션
: JSON 기반의 문서를 저장하고, 검색할 수 있으며 분석 작업도 가능

> 루씬(Lucene): 자바 라이브러리
{: .prompt-info }

**특징**
- 준실시간 검색 시스템
: 실시간이라고 생각도리 만큼 색인된 데이터가 빠르게 검색

>**refresh-interval**
: 색인 이후 이 설정값에 설정된 시간이 지난 뒤 검색이 가능함, 이 값의 기본값이 1초그만큼 색인후 데이터 검색이 빠름
{: .prompt-info .ms-4}

- 고가용성을 위한 클러스터 구성
: 한 대 이상의 노드로도 클러스터를 구성하여 높은 수준의 안정성을 달성하고, 부하 분산이 가능
: 클러스터가 여러 개면, 트래픽을 그만큼 나눠서 처리할 수 있기 때문에 부하 분산이 가능함
: 클러스터가 여러 개면, 하나의 클러스터가 죽어도 나머지 클러스터들이 처리할 수 있어 안정성이 높아짐

- 동적 스키마 생성
: 입력될 데이터들에 대해 미리 스키마를 정의하지 않아도 동적으로 스키마 생성이 가능

- REST API 를 제공
: REST API 기반의 인터페이스를 제공해 비교적 사용을 위한 진입 장벽이 낮음



## 클러스터와 노드 이해하기

### 클러스터

**클러스터**
: 컴퓨터 클러스터는 **여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작**하는 컴퓨터들의 집합을 의미'

**Elasticsearch 클러스터**
: Elasticsearch도 여러 대의 노드들이 각자의 역할을 바탕으로 연결되어 하나의 시스템처럼 동작
: 클러스터 성능이 부족하면 노드를 늘려서 대응할 수 있음(노드를 늘린다고 모두 성능이 좋아지진 않음)
: 어떤 노드에 어떤 요청을 해도 동일한 응답을 해줌
: rdbms의 경우, 읽기 역할을 하는 DB와 쓰기 역할을 하는 DB가 나누어져 있는 경우가 있는데, ?????

### 노드의 종류

_버전이 올라감에 따라 아래 종류 외에도 더 있고, 노드마다 역할이 늘어나지만 공통적인 부분만 작성_

**마스터 노드**
: 클러스터 상태 관리 및 메타데이터 관리
: 실제 마스터 노드로 1개만 존재

**마스터 후보 노드**
: 마스터 노드에 문제가 생겼을 때 바로 마스터 노드가 될 수 있는 노드

**데이터 노드**
: 문서 색인 및 검색 요청 처리

**코디네이팅 노드**
: 검색 요청 처리

**인제스트 노드**
: 색인되는 문서의 데이터 전처리
: 데이터가 들어와서 색인이 되기전에 특정 필드 값들을 수정한 후 넣는 역할

### 클러스터의 특징

![Build source](1.png){:  w="600"}
_마스터 노드가 3개가 있지만 저 중 2개는 후보노드_

**마스터 노드에게 데이터 검색 요청한 상황**
1. `마스터 노드 #0`가 요청을 받음
: 마스터 노드는 검색 요청 처리를 안할 것 같지만, 마스터 노드도 처리함
2. `데이터 노드 #0`에게 데이터 요청
: 마스터 노드는 실제 데이터를 가지고 있지 않기 때문에 실제 데이터를 가지고 있는 데이터 노드에게 데이터를 받아서 해당 값을 보냄
3. `데이터 노드 #0`은 `마스터 노드 #0`에게 데이터를 줌
4. `마스터 노드 #0`은 응답함


**데이터 노드에게 데이터 검색 요청한 상황**
1. `데이터 노드 #0`에게 데이터 검색을 요청함
2. `데이터 노드 #0`은 데이터를 검색함
3. `데이터 노드 #0`은 응답으로 리턴

 → 마스터 노드에게 요청해도 데이터 노드와 똑같은 결과를 받을 수 있음 ⇒ 클러스터이기 때문에

**이상적인 클러스터 구성**

![Build source](2.png){:  w="600"}


**데이터 노드와 코디 네이팅 노드의 직접 접근을 차단**
: 이전 예시처럼 데이터 조회시 마스터 노드로 조회를 해도 똑같은 결과는 나오지만, 불필요한 구간이 생기는데 이를 방지하고자
: 데이터 노드들 앞에 로드밸런서 추가 및 로드밸런서로 접근할 수 있도록
: 코디네이팅 노드들 앞에 로드밸런서 추가 및 로드밸런서로 접근할 수 있도록



## 인덱스와 샤드 이해하기

### 인덱스

**인덱스**
: 문서가 저장 되는 논리적인 공간, 문서를 저장하기 위해서는 반드시 인덱스가 존재해야함, RDBMS에서 database와 비슷한 개념


>**RDBMS와의 비교**
>
>| Elasticsearch | RDBMS |
>| --- | --- |
>| index | database |
>| mapping | schema |
>| document | row |
{: .prompt-info .ms-4}


**인덱스 설계**
: Elasticsearch 인덱스를 설계하는 것이 Elasticsearch를 사용하기 위해 고려해야하는 첫번째

**설계시 고려해야할 사항**
- 사용 패턴
- 문서의 특성

**설계 방식에 따른 장단점**
- 하나의 인덱스만 사용시
  - 장점: 관리할 인덱스 수가 적어 관리 리소스가 적게 발생
  - 단점: 쿼리와 문서의 구조가 복잡함
- 여러개의 인덱스만 사용시
  - 장점: 각각의 경우에 최적화된 쿼리와 문서 구조를 사용할 수 있음
  - 단점: 관리할 인덱스 수가 많아 관리 리소스가 발생할 수 있음

**설계 방법**
: 하나의 인덱스로 단순하게 시작 → 사용 패턴에 따라 인덱스를 별도로 운영

### 샤드(Shard)

**샤드**
: 인덱스에 색인되는 문서가 저장되는 공간, 하나의 인덱스는 반드시 하나 이상의 샤드를 가짐


**종류**
- 프라이머리 샤드
: 문서가 저장되는 원본 샤드, 색인과 검색 성능에 모두 영향을 줌

- 레플리카 샤드
: 프라이머리 사드의 복제 샤드, 검색 성능에 영향을 줌, 프라이머리 샤드에 문제가 생기면 레플리카 샤드가 프라이머리 샤드로 승격


> **색인 과정**
> 1. 프라이머리 샤드에서 문서를 분석함 → 많은 리소스를 사용하는 과정
> 2. 토커나이징을 한 뒤 프라이머리 샤드에 저장함
> 3. 저장이 완료되면, 저장한 내용을 레플리카 샤드로 복제함
{: .prompt-info .ms-4}

**샤드 라우팅**
: 문서가 샤드에 저장되는 순서, 저장되는 방법을 의미
: `Routing Rule = (문서의 ID) % (샤드의 개수)`
: 라우팅 룰 계산식으로 이용해 여러개의 샤드에 문서가 고르게 저장됨
: 샤드의 개수가 바뀐다면, 문서가 저장되는 규칙이 완전히 바뀌게됨

  ⇒ 인덱스 생성 이후 샤드의 개수를 바꿀 수 없음, 샤드의 기본값은 1로 1개만 만듬(성능 안좋아짐)


**인덱스 템플릿**
: 인덱스 패턴에 인덱스 이름의 패턴을 넣고, 설정 값을 입력해주면 인덱스 이름 패턴에 맞는 인덱스를 생성시 해당 설정값이 적용됨



## 매핑 이해하기

**매핑**
: 문서의 구조를 나타내는 정보, elasticsearch는 schemaless가 아니고 미리 정의하지 않아도 될 뿐 인것


**종류**
- 동적 매핑(Dynamic Mapping)
: 처음 색인되는 문서를 바탕으로 매핑 정보를 Elasticsearch가 동적으로 생성
: 어떤 문서가 색인될지 스키마를 미리 정의하지 않아도 됨

- 정적 매핑(Static Mapping)
: 문서의 매핑 정보를 미리 정의 
: 어떤 문서가 색인될지 스키마를 미리 정의
: 문서의 필드들이 가지는 값에 따라 타입을 지정해 줄 필요가 있을 때 사용된다.
ex) 실수 타입의 기본형이 `float`이지만, `double`로 지정해야 할때
: 불필요한 색인이 발생하지 않기 위해
ex) `text`필드는 자동으로 `keyword` 타입이 생성되는데 `keyword` 가 사용되지 않아 막고싶을때

일부 필드만 정적 매핑으로 지정한다면, 나머지 필드들은 동적매핑으로 진행됨

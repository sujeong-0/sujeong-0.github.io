---
title: 카프카 핵심 가이드 - 03 카프카에 메세지 쓰기
description: >-
  카프카 프로듀서를 사용하는 방법을 배워보자.
  KafkaProducer와 ProducerRecord 객체를 어떻게 생성하는지, 어떻게 카프카에 레코드를 전송하는지, 그에 따른 리턴이나 에러를 어떻게 처리하는지와 설정 옵션, 시리얼라이저 등을 살펴보자.
author: ggong
date: 2025-02-18 11:19:00 +0900
categories: [ Book, Kafka ]
tags: [ book, kafka, study, unclear ]
pin: false
media_subpath: '/assets/img/kafka'
references:
  - name: "카프카 핵심 가이드(그웬 샤피라, 토드 팔리노, 라지니 시바람, 크리트 페티 지음 / 이동진 옮김)"
    url: "https://product.kyobobook.co.kr/detail/S000201464167"
---

## 프로듀서 개요

서로 다른 요구 조건은 카프카에 메시지를 쓰기 위해 퓨로듀서 API를 사용하는 방식과 설정에 영향을 미친다.


![Build source](3-1.png){: .light .normal }
_카프카에 데이터를 전송할 때 수행되는 주요 단계들_

1. `ProducerRecord` 객체를 생성한다.
: 레코드가 저장될 토픽과 밸류 지정을 필수사항이다.
: 키와 파티션 지정은 선택사항이다.

2. 생성한 객체를 직렬화한다.
3. 해당 데이터를 파티셔너에게 보낸다.
: 파티션을 명시적으로 지정했다면 이 과정은 생략된다.
: 파티셔너는 파티션을 결정하는 역할을 한다.

4. 토픽 파티션에 저장될 레코드들을 모아 레코드 배치에 추가한다.
5. 별도의 스레드가 이 레코드 배치를 적절한 카프카 브로커에게 전송한다.
6. 브로커가 메시지를 받으면 응답을 돌려준다.
: 성공했을 경우에는 `RecordMetadata`를, 실패했을 때는 에러가 리턴된다.


## 카프카 프로듀서 생성하기

카프카에 메시지를 쓰려면 원하는 속성을 지정해서 프로듀서 객체를 생성해야한다.
이때 프로듀서는 아래의 3개의 필수 속성값을 갖는다.

### 필수 속성값

`bootstrap.servers`
: 프로듀서가 사용할 브로커의 `host:port` 목록이다.
: 모든 브로커를 포함할 필요는 없지만, 최소 2개 이상을 지정할 것을 권장한다.

`key.serializer`
: 키 값을 직렬화하기 위해 사용하는 시리얼라이저 클래스 이름이다.
: `org.apache.kafka.common.serialization.Serializer` 인터페이스를 구현하는 클래스의 이름이 지정되어야한다.
: `VoidSerializer`를 사용해 키 타입으로 `void`를 설정할 수 있다.
 
`value.serializer`
: 밸류 값을 직렬화하기 위해 사용하는 시리얼라이저 클래스 이름이다.


### 프로듀서의 생성 방법

```java
Properties kafkaProperties = new Properties();
kafkaProperties.put("bootstrap.servers", "broker1:9002,broker2:9002");
kafkaProperties.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
kafkaProperties.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

KafkaProcuder<String, String> producer = new KafkaProducer<String,String>(kafkaProperties);
```
_프로듀서의 생성방법_
{: .code-description }

- <span>1</span>`Properties` 생성 
- <span>3~4</span>메시지의 키값과 밸류값으로 문자열을 사용할 것이므로, 기본제공되는 시리얼라이저를 사용
- <span>6</span>`Properties`를 넘겨줌으로써 새로운 프로듀서 생성
{: .code-description }

### 메시지 전송 방법

파이어 앤 포켓
: 메시지를 서버에 전송만 하고 끝내는 방식으로, 성공 혹은 실패 여부에 관심을 두지 않는다.
: 프로듀서는 [재시도할 수 있는 실패](#카프카-프로듀서-생성하기-실패){: .question }에서는 재전송 실패를 하지만, 
재시도를 할 수 없는 에러 발생시에는 재시도 하지 않고 실패에 대한 처리가 없어 메시지가 유실되며 프로듀서는 알 수 없다.

동기적 전송
: 메시지를 전송하고 다음 메시지를 전송하기 전까지 `get()`을 호출해 작업이 완료될까지 기다려 성공 여부를 확인한다.

비동지적 전송
: 카프카는 언제나 비동기적으로 작동한다.
: 응답을 받는 시점에서 자동으로 콜백 함수가 호출된다.


## 카프카로 메시지 전달하기

```java
ProducerRecord<String,String> record =new ProducerRecord("CustomerCountry", "Precision Products", "France");
try{
    producer.send(redord);
}catch(Exception e){
    e.printStackTrace();  
}
```
_메시지 전송_
{: .code-description }

- <span>1</span>`ProducerRecord` 생성
- <span>3</span>`ProducerRecord`를 전송하기 위해 프로듀서 객체의 `send()` 사용
: 메시지는 버퍼에 저장 -> 별도에 스레드가 브로커로 보냄 -> `RecoredMetadata`를 포함한 `Future`객체를 리턴 -> 이 코드에서는 값을 무시함
- <span>6</span>프로듀서가 카프카로 메시지를 보내기 전에 에러가 발생할 경우, catch절이 실행
: ex) 직렬화 실패(SerializationException), 버퍼가 가득참(TimeoutException), 전송 작업을 수행하는 스레드에 인터럽트 발생시(InterruptException)등
{: .code-description }


### 동기적으로 메시지 전송하기

동기적으로 메시지를 전송할 경우, 전송을 요청하는 스레드는 이 시간동안 아무것도 안하면서 기다려야해서 성능이 크게 낮아지기 때문에 잘 사용되지는 않는다.


```java
ProducerRecord<String,String> record =new ProducerRecord("CustomerCountry", "Precision Products", "France");
try{
    producer.send(redord).get();
}catch(Exception e){
    e.printStackTrace();  
}
```
_동기적으로 메시지 전송_
{: .code-description }

- <span>3</span> 카프카로부터 응답이 올 때까지 `Future.get()`을 사용해 대기 
: 성공적으로 전송되지 않았으면 예외를 발생시키고, 성공했다면 `RecordMetadata`객체를 받는데 여기에서 메시지가 쓰여진 오프셋 등의 메타데이터를 가져올 수 있다.
- <span>5</span> [재시도할 수 있는 실패](#카프카-프로듀서-생성하기-실패){: .question }라면 재시도 횟수를 넘었을 경우 실행되고, 재시도할 수 없는 실패라면 바로 실행된다. 
{: .code-description }



> 재시도할 수 있는 실패와 재시도할 수 없는 실패
> 재시도할 수 있는 실패
: 메시지를 다시 전송함으로써 해결될 수 있는 에러를 의미한다.
: 연결 에러 - 연결이 회복되면 해결될 수 있다.
>
> 재시도할 수 없는 실패
: 메시지 크기가 너무 큰 경우와 같이 재시도를 한다고 해서 해결되지 않는 에러를 의미한다.
>
> 재시도할 수 있는 실패에서는 카프카가 자동으로 재시도하도록 `KafkaProducer`를 설정할 수 있어, 이 경우 재전송 횟수를 다 소진하면 예외를 발생시킨다.
{: .prompt-question id="카프카-프로듀서-생성하기-실패" .ms-5 }

### 비동기적으로 메시지 전송하기

메시지를 비동기적으로 전송한다면, 많은 메시지를 보낸다고 하더라도 시간은 굉장히 짧게 소요될 것이다.
전송시 응답으로 메타데이터를 주는데 메시지가 완전히 실패한 경우가 아니라면, 이 메타 데이터가 필요한 경우는 대부분 없다.
비동기적으로 전송할 때 에러도 같이 처리하기 위해, **레코드 전송시 콜백을 지정할 수 있도록 한다.**

```java
private class DemoProducerCallback implements Callback {
  @Override
  public void onCompletion(RecordedMethod recordedMethod, Exception e) {
    if(e != null) {
      e.printStackTrace();
    }
  }
}

ProducerRecord<String,String> record =new ProducerRecord("CustomerCountry", "Precision Products", "France");
producer.send(record, new DemoProducerCallback);
```
_비동기적으로 메시지 전송_
{: .code-description }

- <span>1~8</span> 콜백함수 작성
: `org.apache.kafka.clients.producer.Callback`인터페이스를 구현하는 클래스
- <span>3~7</span> 콜백함수 작성
: 만약 카프카가 에러를 리턴한다면, `onCompletion()` 메서드가 `null`이 아닌 `Exception`객체를 받게 된다.
- <span>11</span> 콜백함수 지정
{: .code-description }

## 프로듀서 설정하기

프로듀서는 굉장히 많은 설정값을 가지고 있지만, 모두를 설정할 필요는 없다.
몇몇 설정값은 메모리 사용량이나 성능, 효율, 신뢰성에 영향을 미치는데, 이부분에 대해 알아보자.

### 클라이언트 아이디

`client.id`
: 브로커가 프로듀서를 구분하기 위해 사용되는 값이다.
: 임의의 문자열을 사용할 수 있다.

### 쓰기 작업 성공 기준

`acks`
: 작업이 성공했다고 판별하기 위해, **얼마나 많은 파티션 레플리카가 해당 레코드를 받아야 하는지** 결정하는 설정값이다.

- `acks=0`
: 성공적으로 전달되었다고 간주하고 브로커의 응답을 기다리지 않는다.
: 에러가 발생해 브로커가 **메시지를 못받은 경우 메세지는 그대로 유실**된다. 
: 대신 매우 빠르게 메시지를 보낼수 있어, **높은 처리량이 필요할 때** 사용될 수 있다.

- `acks=1`
: 리더 레플리카가 메시지를 받는 순간, 성공했다는 응답을 받는다.
: 리터에 크래시가 난 상태에서 해당 메시지가 복제가 안 된 채로 새 리더 선출시, **메시지가 유실될 수** 있다.

- `acks=all`
: 모든 인-싱크 레플리가에 전달된 뒤에, 성공했다는 응답을 받는다.
: 메시지가 유실되지 않는 방법으로 가장 **안전한 형태**이지만, **지연 시간은 더 길어**진다.

### 메시지 전달 시간

카프카 2.1부터 `ProducerRecord`를 보낼 때 걸리는 시간을 두 구간으로 나누어 따로 처리할 수 있도록 했다.
- `send()`호출 ~ `send()`결과 리턴: 이 시간은 `send()`를 호출한 스레드는 블록된다.
- `send()`결과 리턴 ~ 콜백 호출: 전송이 실제 완료되기까지 걸린 시간(=`ProducerRecord`가 전송을 위해 배치에 추가된 시점 ~ (성공, 실패, 재시도 시간 소진)의 시간)과 동일하다.

![Build source](3-2.png)
_카프카 프로듀서 내부에서 전달 시간을 작업별로 나눈 개념도_

프로듀서 내부에서의 데이터의 흐름과 서로 다은 설정 매개변수들이 어떻게 상호작용하는지를 보여준다.
send() 호출 -> 배치(Batching) -> 전송 대기(Await send) -> 재시도(Retries): 생략 가능 -> Inflight(전송 중)


`max.block.ms`
: `send()`호출 시 [`paritionsFor`](#메시지-전달-시간-paritionsFor){: .question }를 호출해 명시적으로 메타데이터를 요청했을 때,`send()`리턴의 제한시간을 설정한다.
: `send()`는 프로듀서의 전송 버퍼가 가득 차거나 메타데이터가 아직 사용할 수 없을 때 블록된다.

> `paritionsFor`
: 프로듀서에서 특정 토픽의 파티션 정보를 조회하는 메서드로, 토픽에 어떤 파티션들이 있는지를 미리 가져올 수 있다.
: 프로듀서는 메타데이터(파티션 정보)를 캐싱하지만, `send()`호출 시 필요하면 새로 요청하는데 이때 사용된다.
{: .prompt-question .ms-4 id="메시지-전달-시간-paritionsFor" }

`delivery.timeout.ms`
: 레코드 전송 준비가 완료된 시점(=레코드가 배치에 저장된 시점)~브로커의 응답을 받거나 전송을 포기하게 되는 시점의 제한시간을 결정한다.
: 이 값은 `linger.ms`와 `request.timeout.ms`보다 커야한다.

> 재전송을 **횟수가 아닌 시간**으로 설정하는 방법
> 메시지 전송에 기다릴 수 있는 시간을 `delivery.timeout.ms`로 설정하고, `retries`를 기본값으로 두는 것(사실상 무한으로 두는 것)이다.
> 이렇게 설정하면 성공하거나 재시도할 시간이 다 고갈될 때 까지 재전송을 반복한다.
{: .prompt-tip .ms-4 }

`request.timeout.ms`
: 데이터를 전송할 때 서버로부터 응답을 받기 위해 얼마나 기다릴 것인지를 설정한다.
: 재시도 시간, 실제 전송 이전에 소요되는 시간 등은 포함하지 않는다.
: 메시지를 기준으로 최종적으로 결과가 나오는 전제시간이 아닌, **최초전송 이나 재전송 각 케이스의 응답시간을 의미한다.**
: 여기서 타임아웃 발생시 `TimeoutException`과 함께 콜백을 호출한다.

`retries`
: 재시도할 수 있는 실패일때 메시지 전송을 포기하고 에러를 발생시킬 때까지, 메시지를 재전송하는 횟수를 설정한다.

`retry.backoff.ms`
: 재시도할 수 있는 실패일때 재전송시, 재전송 사이의 간격을 설정한다.
: 현재 버전에서는 이 값을 조정하는 방법보단, 크래시난 브로커가 정상으로 돌아오기까지의 시간을 테스트한 뒤 `delivery.backoff.ms`를 설정하는 것을 권장한다.

### 배치

`linger.ms`
: 적절한 크기의 배치를 만들기 위해 약간의 지연을 주는 역할로 현재 배치를 전송하기 전까지 대기하는 시간을 결정한다.
: 현재 배치가 가득 차거나 or 이 값에 설정된 시간이 되었을 때 배치를 전송한다.

`batch.size`
: 같은 파티션에 다수의 레코드가 전송될 경우 배치 단위로 모아서 한번에 전송하는데, 각 배치에 사용될 메모리의 양(바이트 단위로)을 결정한다.
: 각 배치가 가득 찰 때까지 기다린다는 의미는 아니기 떄문에 큰 값을 유지 한다고 해서 메시지 전송에 지연이 발생되지 않는다.

`buffer.memory`
: 메시지를 전송하기 전에 메시지를 대기시키는 버퍼의 크기를 설정한다.
: send()는 max.block.ms 동안 블록되어 버퍼 메모리에 공간이 생기기를 기다리게 되는데, 확보되지 않으면 예외를 발생시킨다.

> **배치와 버퍼 메모리의 관계**
> 배치가 곧 버퍼 메모리의 일부로 버퍼 메모리는 **메시지가 전송되기 전에 머무르는 공간**이고,
> 이 공간에서 일정 크기인 `batch.size`로 메시지가 묶여 **배치를 형성한 후 전송**되는 것이다.
> 프로듀서는 배치를 파티션 별로 관리하기 때문에, 배치는 파티션 개수만큼 생성될 수 있어,
> **버퍼 메모리는 여러 개의 배치를 수용할 수 있어야 하므로 파티션 개수와 트래픽을 고려해 충분히 크게** 설정 되어야한다.
{:.prompt-question .ms-4 }

### 데이터의 전송시 

`compression.type`
: 기본적으로 메시지는 압축되지 않은 상태로 전송되는데, `snappy`, `gzip`, `lz4`, `zstd` 중 하나로 지정시 해당 알고리즘으로 압축되어 전송된다.

- `snappy`: CPU 부하 적음, 압축률 괜찮음 -> 압축 성능과 네트워크 대역폭 둘 다 중요할 때
- `gzip`: CPU 부하 약간, 압축률 더 좋음 -> 네트워크 대역폭이 중요할 때
{: .ms-4}

`max.in.flight.request.per.connection`
: 프로듀서가 응답을 받지 못한 상태에서 전송할 수 있는 최대 메시지의 수를 설정한다.
: 1 이상으로 설정시에는 순서가 뒤바뀔 수 있는데 `enable.idempotence`값을 설정해 순서가 바뀌지 않도록 할 수 있다.

> 순서가 바뀌는 예시
> 1. 메시지 1번 보냄
> 2. 메시지 2번 보냄
> 3. 매시지 1번 처리 중 장애 발생, 재전송 대기
> 4. 메시지 2번 처리완료
> 5. 메시지 1번 재전송
> 6. 메시지 1번 처리완료
{: .prompt-info .ms-4}

`max.request.size`
: 프로듀서가 전송하는 쓰기 요청의 크기를 결정한다.
: 메시지의 최대크기와 한 번에 요청에 보낼 수 있는 메시지의 최대 개수 역시 제한한다. 
: 브로커가 받아들일 수 있는 최대 메시지 크기를 결정하는 `message.max.bytes`를 동일하게 맞춰야한다.

`receive.buffer.bytes`, `send.buffer.bytes`
: 데이터를 읽거나 쓸 때 소켓이 사용하는 TCP 송수신 버퍼의 크기를 결정한다.
: -1로 설정시 운영체제의 기본값이 사용된다


### 정확히 한번
0.11부터 카프카는 **"정확히 한 번(exactly once semantics)"**를 지원하기 시작했다. 
[멱등적 프로듀서](#정확히-한번-멱등적-프로듀서){:.question}는 간단하면서도 가장 강력한 부분이라고 할 수 있다.

> **멱등적 프로듀서**
> 일한 메시지를 여러 번 전송해도 **최종적으로 브로커에 단 한 번만 기록되도록 보장**하는 Kafka 프로듀서의 기능이다.
> `enable.idempotence=true`옵션을 설정하면 멱등적 프로듀서 기능이 활성화된다.
{:.prompt-question id="정확히-한번-멱등적-프로듀서"}

1. 신뢰성을 최대하는 방향으로 프로듀서 설정(`acks=all`, `delivery.timeout.ms`는 큰 값으로 설정)하면 메시지는 최소 한번은 카프카에 쓰여지게 된다.
2. 이러한 상황에서 브로커(=리더)가 프로듀서로 부터 메시지를 받아 로컬 디스크에 쓰고, 다른 브로커(=팔로워)에도 성공적으로 복제되었다고 가정한다.
3. 브로커는 프로듀서에게 응답을 보내기 전에 크래시가 발생했다면, 프로듀서는 응답을 받지못해 `request.timeout.ms`만큼 기다렸다가 재선송을 시도한다.
4. 이때 브로커는 리더를 새로 선출하는데 최근 데이터를 저장했던 브로커(=팔로워)가 리더로 승격해 리더를 선출했다면, <kbd>2</kbd>에서 팔로워였던 브로커라 이미 데이터가 저장되어 있다.
그런 상태에서 한번 더 데이터를 받게 되면 데이터가 중복으로 저장되게 된다.

`enable.idempotence`
: true로 설정시 프로듀서는 레코드를 보낼 떄 마다 순차적인 번호를 붙여서 보내게되고,
브로커가 같은 프로듀서로부터 동일한 번호의 레코드를 2개 이상 받은 경우에는 하나만 저장하게 되며 문제를 발생시키지 않는 `DuplicateSequenceException`을 받게 된다.
: 만약, 정상적인 순서대로 전송되지 않으면(=seq가 순차적이지 않으면) `OutOfOrderSequenceException`을 발생시킨다.

### 정리

1. **메시지 생성**
2. **<kbd>send()</kbd>메시지 전송**
   1. [생략가능] 토픽의 파티션 정보가 없다면 `partitionsFor()` 호출
   2. `send()` 호출
3. **<kbd>Batching</kbd>메시지를 배치에 저장**
   1. 메모리(`buffer.memory`) 내의 파티션별 배치(batch) 에 저장
   2. 각 배치는 지정된 시간(`linger.ms`) 있다면 해당 값 만큼 기다리며 배치에 저장
   3. [생략가능] 메시지 압축(`compression.type`)이 설정된 경우, 배치 데이터를 압축
4. **<kbd>Await send</kbd>메시지 전송**
   1. 지정된 배치 사이즈(`batch.size`)가 꽉 차면 전송하거나, 가득 차지 않아도 지정된 시간(`linger.ms`)이 지나면 전송
   2. TCP 소켓을 통해 브로커로 메시지를 최대 요청 개수(`max.in.flight.requests.per.connection`)만큼 전송
   3. 브로커 응답을 `acks` 설정에 따라 브로커의 응답을 기다림
5. **<kbd>Retries</kbd>전송 실패 시 재시도**
   1. 지정된 응답 시간(`request.timeout.ms`)이 지나면 응답을 받지 못했다고 판단해, 지정된 대기 시간(`retry.backoff.ms`)만큼 대기 후 다시 전송
   2. 지정된 재전송 횟수(`retries`)만큼 반복
   3. [생략가능] `enable.idempotence=true` 설정 시,멱등적 프로듀서 중복 체크
6. **<kbd>Inflight</kbd>최종 전송 완료 or 실패**
   1. 성공시, 메시지 정상적으로 전달되고 콜백 호출
   2. 실패시 (`delivery.timeout.ms`)가 지나면 최종적으로 전송을 포기하며, `TimeoutException` 발생
        


## 시리얼라이저

## 파티션

## 헤더

## 쿼터, 스로틀링

## 요약

---
title: Nosql?LSM tree?
description: LSM tree는 무엇이고, B+tree와는 어떻게 다를까
author: ggong
date: 2025-03-27 20:59:22 +0900
categories:
  - Study
  - Data
tags:
  - b+tree
  - lsm-tree
  - study
  - nosql
pin: false
media_subpath: /assets/img/_posts/study/data
references:
  - url: https://www.youtube.com/watch?v=i_vmkaR1x-I
    name: NoSQL 데이터베이스가 빠른 이유 | LSM Tree 완전정복 | DB 의 데이터 저장 방법
    fieldGroup: references
  - url: https://en.wikipedia.org/wiki/Log-structured_merge-tree
    name: Log-structured merge-tree
    fieldGroup: references
  - url: https://medium.com/@dwivedi.ankit21/lsm-trees-the-go-to-data-structure-for-databases-search-engines-and-more-c3a48fa469d2
    name: "LSM Trees: the Go-To Data Structure for Databases, Search Engines, and More"
    fieldGroup: references
  - url: https://jaeyeong951.medium.com/%EC%83%89%EC%9D%B8-index-%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C-lsm-%ED%8A%B8%EB%A6%AC-b-%ED%8A%B8%EB%A6%AC-7a4ab7887db5
    name: "색인(index)의 두 가지 형태 : LSM 트리 & B 트리"
    fieldGroup: references
---

## LSM Tree란?

LSM Tree(로그 구조 병합 트리, LSMT)
: Log Structured Storage Engine 중 하나 입니다.
: key-value 형식으로 데이터가 저장됩니다.
: Nosql DB 중 일부(RocksDB, Cassandra, HBase 등)가 LSM Tree를 기반으로 합니다.

> Nosql DB로 유명한 mongoDB는 LSM tree 기반이 아닙니다.

> Log Structured Storage Engine
> : LogFile을 기반으로 작동하는 방식
>
> LogFile
> : Append-only 파일
> : 한번 쓰여진 정보는 바뀌지 않고, 새로운 내용은 항상 파일의 끝에 추가되는 파일
{:.prompt-info}

### LSM Tree 구조

LSM tree는 데이터를 데이터를 하나로 저장하지 않고, 2개의 트리(`MemTable`, `SSTable`)에 나눠서 저장합니다.

`MemTable`
: LSM Tree에서 메모리에서 데이터를 관리하는 곳 입니다.
: `MemTable`에는 데이터가 트리의 구조로 정렬되어 있습니다.
: `MemTable`에서 관리하는 데이터의 양이 임계치를 넘어가게되면, `SSTable`로 데이터를 옮깁니다.
: `SSTable`에 저장되기 전까지는 Log File을 Disk에 작성해 서버 장애 발생시에도 데이터가 누락되지 않도록 관리됩니다.
  > LSM tree에서 LogFile
  > `MemTable`에서 `SSTable`로 데이터가 옮겨질때, LogFile의 모든 내용도 삭제합니다.
  > Append Only로 동작하기 때문에, 데이터가 한번 입력된 이후 데이터를 수정하더라도 내용이 수정되지 않고, 파일 끝에 추가됩니다.
  {:.prompt-info}

`SSTable(Sorted String Table)`
: LSM Tree에서 데이터를 디스크에 관리하는 곳 입니다.
: 이후에 설명 하겠지만, `SSTable`은 디스크 내에 여러개로 존재합니다.
: 여러개의 `SSTable`이 병합 됩니다.
: `SSTable`의 데이터는 변하지 않는 데이터(immutable)로, 수정되지 않습니다.

## LSM tree의 동작 과정

### LSM Tree의 데이터 쓰기

LSM tree에서 데이터를 쓴다고 하면, 데이터는 어떻게 저장될까요?

> 이미지가 잘 안보이는데, 클릭하면 확대가 가능합니다.

데이터의 `MemTable`의 임계치를 4라고 가정한 상태에서 데이터 입력 과정을 작성했습니다.

1. 첫번째 데이터 삽입

    ![LSM tree compaction](lsm-tree_insert1.png){: .center width="700"}

2. 두번째 데이터 삽입

    ![LSM tree compaction](lsm-tree_insert2.png){: .center width="700"}

3. 세번째 데이터 삽입

    ![LSM tree compaction](lsm-tree_insert3.png){: .center width="700"}

4. 첫번째 데이터 수정
  
    ![LSM tree compaction](lsm-tree_insert4.png){: .center width="700"}

5. 저장
  
    ![LSM tree compaction](lsm-tree_insert5.png){: .center width="700"}

> 데이터 쓰기 과정, 출처: [NoSQL 데이터베이스가 빠른 이유, LSM Tree 완전정복,  DB 의 데이터 저장 방법](https://www.youtube.com/watch?v=i_vmkaR1x-I)

- 1~4번의 과정까지는 데이터가 들어오는대로 `MemTable`과 LogFile에 저장합니다.
  - 1번째로 들어온 데이터가 이후 4번의 과정에서 수정되는데, LogFile에는 데이터가 추가된 것처럼 동작하고, `MemTable`에서는 데이터가 수정되는 것을 볼 수 있습니다.
- 5번 과정처럼 일정 단위가 되서 `SSTable`로 데이터를 옮기면 `MemTable`과 LogFile의 내용은 지웁니다.

### LSM Tree의 데이터 읽기

#### 단일 데이터 읽기

이렇게 데이터가 저장되면, 어떻게 데이터를 읽어올까?

![LSM tree compaction](lsm-tree_read.png){: .center width="700"}

`SSTable`은 데이터가 계속 저장됨에 따라 계속 늘어나지만 일단 2개가 있다고 가정해 봅시다.

이 상태에서 key값이 2113인 데이터를 찾는 과정은 아래와 같습니다.

1. `MemTable`에서 조회
2. 없으면 `SSTable-1`에서 조회
3. 없으면 `SSTable-2`에서 조회

이렇게 된다면, 데이터가 MemTable에 있었다면 빠를 것이고, SSTable2와같이 Disk에 있는 데이터 중 마지막 데이터라면 매우 느립니다.
최악의 경우에는 모든 데이터를 다 확인해야한다는 단점이 있죠.
물론, 각 SSTable 안에는 데이터가 정렬되어있어 빠르게 검색할 수 있지만, `SSTable`은 disk에 있어 Memory보다는 느립니다.

그러면 메모리에 인덱스가 있으면 좋지 않을까요? 그래서 인덱스가 상황을 가정해보겠습니다.

![LSM tree compaction](lsm-tree_read_index.png){: .center width="700"}
_출처: [NoSQL 데이터베이스가 빠른 이유 | LSM Tree 완전정복 | DB 의 데이터 저장 방법](https://www.youtube.com/watch?v=i_vmkaR1x-I)_

이때의 인덱스는 Hash index로, 각 `SSTable`의 정보를 key와 byte offset을 가지고 있으며, `SSTable`의 데이터 시작과 끝의 값만 가지고 있습니다.

그럼 이때 key값이 2113인 데이터 조회 과정은 아래와 같습니다.

1. `MemTable`에서 조회
2. 없으면 `index1`에서 조회하려는 데이터의 key가 포함되는지 확인
  = 조회하려는 데이터의 key가 index의 key 범위에 포함되는지 확인
3. 없으면 `index2`에서 조회하려는 데이터의 key가 포함되는지 확인
   = 조회하려는 데이터의 key가 index의 key 범위에 포함되는지 확인
4. `index2`에 포함되니까 byte offset을 통해 바로 disk에 있는 `SSTable-2`에 접근
5. `SSTable-2` 내에서 조회

인덱스의 값은 SStable의 모든 값이 아닌 각 SSTable의 시작값과 마지막 값만 가지고 있는데, SSTable 내의 값은 이미 정렬되어있기 때문입니다.
이러한 인덱스를 LSM Tree에서는 <kbd>블룸 필터</kbd> 라고 합니다.

![LSM tree merge](lsm-tree_bloom-filter.png){: .center width="600"}
_블룸 필터, 출처: [색인(index)의 두 가지 형태 : LSM 트리 & B 트리](https://jaeyeong951.medium.com/%EC%83%89%EC%9D%B8-index-%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C-lsm-%ED%8A%B8%EB%A6%AC-b-%ED%8A%B8%EB%A6%AC-7a4ab7887db5)_

블룸 필터
: `데이터가 존재할 수 있음`이나 `데이터가 확실히 없음` 을 알려줍니다.
: Memory에 위치합니다.

#### 범위 데이터 읽기

이렇게하면 특정 데이터를 조회할 때 빠르게 조회할 수 있습니다.
그러면 하나의 데이터가 아니라 여러개의 데이터인데, 범위로 지정해서 조회한다면 어떻게 동작할까요?

범위 쿼리를 한다면, 범위 데이터의 시작점과 끝 점을 찾아 각 데이터에 대해 단일 데이터 조회와 같은 방식으로 동작합니다.

비효율적이지만, Hash기반의 index이기 때문에 나오는 단점입니다.

### compaction

**SSTable의 데이터는 불변데이터라서, 데이터가 이후에 수정되었을 때 실제 데이터에 접근하여 수정하지 않습니다.**

> 만약 굉장히 예전에 데이터를 작성해 데이터가 추가되어 `SSTable-1`로 저장되어있는 상태에서,
> 해당 데이터를 수정한다고 하면, 새로 데이터가 저장되는 것처럼 작성됩니다.
> 그러면 같은 key를 가진 데이터가 `SSTable-1`와 `SSTable-N`에 중복으로 저장됩니다.
{:.prompt-info}

그러면 전체 SSTable을 봤을 때에는 중복데이터가 많게 되는데, 결국 디스크 공간 낭비로 이어지게 됩니다.
어떻게 하면 이것을 해결할 수 있을까?

LSM tree는 compaction이라는 과정을 통해 이를 해결합니다.

![LSM tree merge](lsm-tree_read_index2.png){: .center width="600"}
_compaction 대상을 표시, 출처: [색인(index)의 두 가지 형태 : LSM 트리 & B 트리](https://jaeyeong951.medium.com/%EC%83%89%EC%9D%B8-index-%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C-lsm-%ED%8A%B8%EB%A6%AC-b-%ED%8A%B8%EB%A6%AC-7a4ab7887db5)_

Compaction
: 2개의 `SStable`을 1개의 SSTable로 합치는 과정에서, 중복된 키 값이 있다면 최신 값만 유지하고 나머지 데이터는 버린다.
: 각 `SSTable`은 정렬되어 있는 상태기 때문에 병합 정렬을 사용해 합쳐진다.(merge)
: 합쳐진 `SSTable`에 대해서는 인덱스가 필요 없기 때문에 index의 데이터도 줄인다.

또, SSTable을 진행하는 이유는 Disk 내에 여러개로 나뉘어진 SSTable이 많아지게 되면, 그만큼 Index에 데이터 크기도 늘어나야합니다.
그래서 이를 합치며 관리하는데, 레벨에 따라 관리하며 각 레벨의 특정 임계치가 넘어가면 Compaction을 진행하여 합칩니다.

- MemTable의 내용을 level 0
- MemTable에서 Disk로 넘어온 SSTable은 level 1
- level 1의 SSTable을 2개를 compaction 한 것을 SSTable level 2
- level n의 SSTable을 2개를 compaction 한 것을 SSTable level n+1

## 전체 구조

![LSM tree structure](lsm-tree.png){: .center width="600"}
_LSM tree의 전체 구조, 출처: [NoSQL 데이터베이스가 빠른 이유 | LSM Tree 완전정복 | DB 의 데이터 저장 방법](https://www.youtube.com/watch?v=i_vmkaR1x-I)_

LSM tree의 전체 구조를 본다면 이렇게 됩니다.

- 메모리(Memory): MemTable과 index인 Bloom Filter가 있습니다.
- 디스크(Disk): 여러 레벨의 SSTable이 있으며, 각 레벨 별로 SSTable은 여러개 존재할 수 있습니다.

## LSM tree? LSM Tree!!!

B+tree는 DB를 공부할 때 항상 RDB를 기준으로 공부했기 때문에 종종 들었지만, LSM Tree라는 단어를 처음 들었을 때 너무 생소했다.
그래도 이 글을 정리하며 LSM tree기반의 DB가 있다는 것을 알게되었고,
만약 내가 DB를 골라서 개발할 수 있다면, 애플리케이션이나 서비스의 특성에 따라 다른 DB를 선택해야겠구나 라는 생각을 가지게 됐다.
그 일부로 일단 B+tree와 LSM tree 둘 중에 하나는 선택할 수 있으니...

No sql DB는 생각보다 다양하니까 각 DB의 구조나 동작 방식에 대해 더 관심을 가져서, 서비스마다 좀 더 적절한 DB를 선택할 수 있는 능력을 길러야겠다.
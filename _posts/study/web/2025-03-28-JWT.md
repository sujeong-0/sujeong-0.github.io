---
title: JWT(Json Web Token)
description: JWT가 왜 인증에 사용될  수있을까? 어떻게 사용될까?
author: ggong
date: 2025-03-28 08:27:55 +0900
media_subpath: /assets/img/_posts/study/web
tags:
  - study
  - web
  - jwt
categories:
  - Study
  - Web
references:
  - name: JSON 웹 토큰
    url: https://ko.wikipedia.org/wiki/JSON_%EC%9B%B9_%ED%86%A0%ED%81%B0
    fieldGroup: references
  - url: https://datatracker.ietf.org/doc/html/rfc7519
    name: RFC 7519 JWT
    fieldGroup: references
  - url: https://wikidocs.net/214637#_3
    name: wiki docs - 숏텀 리눅스
    fieldGroup: references
  - url: https://javaplant.tistory.com/26
    name: 암호화 양방향, 단방향, 공개키(비댕칭키), 비공개키(대칭키) 개념/분류 알고리즘 정리
    fieldGroup: references
  - url: https://datatracker.ietf.org/doc/html/rfc7515
    name: RFC 7515(JWS)
    fieldGroup: references
pin: false
---


## JWT란?

JWT(Json Web Token)은 JSON 객체로 인코딩된 클레임 세트를 나타냅니다.

여기까지만 보면 이해가 안되실텐데, 아래의 설명을 통해 알아봅시다.

### JWT의 구성

JWT는 어떻게 생겼는지부터 알아봅시다.

![JWT Structure](jwt-structure.png){: .center w="600"}

#### 헤더(Header)

헤더에는 토큰 자체에 대한 정보를 담고있습니다.
토큰을 암호화할 때 어떤 알고리즘을 썼는지, 토큰의 타입이 무엇인지 등의 정보를 작성합니다.

> **JOSE 헤더(JavaScript Object Signing and Encryption)**
> RFC 7519 문서에서는 JWT의 헤더를 이렇게 지칭하고 있습니다.
> 이 의미는 JWT에 사용된 **암호화 및 서명 알고리즘 정보를 담고 있는 JSON 객체**를 의미합니다.
{: .prompt-info}

#### 페이로드(Payload)

페이로드에는 실제 통신에서 주고 받을 때 사용하기 위한 클레임(실제 정보)이 담겨있습니다.
보통은 담고자 하는 정보가 여러개라, 클레임들(Claims)이 담겨있습니다.

클레임(Claim)
: key-value 형태로 된 정보

RFC 7519의 표준에서는 클레임을 3가지 종류로 나눕니다.

- Registered Claim
  : 표준화 된 클레임으로, 권장되지만 필수는 아닙니다.
  - `iss` (Issuer): 토큰 발급자
  - `sub` (Subject): 토큰 제목 또는 사용자 식별자
  - `aud` (Audience): 토큰 대상자
  - `exp` (Expiration Time): 만료 시간 (Unix Timestamp)
  - `nbf` (Not Before): 토큰 활성 시작 시간
  - `iat` (Issued At): 토큰 발급 시간
  - `jti` (JWT ID): 토큰 고유 식별자
- Public Claim
  : 사용자 정의 클레임으로, 공개용 정보 전달을 위해 사용됩니다.
  : Registered Claim 외에는 사용자가 자유롭게 정의할 수 있는데, 이 부분은 다른 여러 애플리케이션이나 서비스의 JWT와 충돌할 수 있습니다.
    이를 방지하고자 Public Claim을 작성해 충돌을 방지합니다.
    RFC 7519에서는 이 내용을 발급하는 곳의 URI로 정의하는 방법을 권장합니다.
  ```json
  {
    "sub": "1234567890",
    "name": "John Doe",
    "email": "john.doe@example.com",
    "https://www.googleapis.com/auth/userinfo.profile": true,
    "https://www.googleapis.com/auth/userinfo.email": true
  }
  ```
  _구글의 Public Claims 예시_
- Private Claim
  : JWT 발급자와 수신자 간에 정의된 비공개 클레임으로, 실제 주고 받을 데이터들을 의미합니다.

#### 서명(Signature)

서명은 JWT를 사용했을 때 안전함을 증명하는, 무결성을 보장하는 부분입니다.
서명은 앞에 정의했던 헤더, 페이로드, secret 내용을 합친뒤 암호화 합니다.

Secret
: 발급하는 곳에서만 알고있는 정보로, 비밀번호와 같은 내용입니다.

### 서명(Signature): JWT가 안전한 이유

가장 궁금했던 부분입니다.
어떻게 서명을 통해 무결성이 보장되며, 인증 과정에서는 어떻게 서명을 이용해야할지가 가장 궁금했습니다.

#### 검증 과정: 서명의 무결성을 확인하는 법

서버에서 JWT의 무결성은 어떻게 확인할까요?

> JWT의 무결성
> : JWT가 변조되지 않았다는 것을 의미
{: .prompt-info}

> 여기서 설명하는 검증 방식은 JWS의 방식입니다. 
> 아래에서 JWS와 JWE에 대해 설명하고 있으니, 먼저 이를 통해 이해하면 좋습니다.
{: .prompt-info }

**새로운 서명(Header + Payload + secret)을 만들어, 실제 서명과 비교**하여 무결성을 확인합니다.

1. JWT을 `Header` + `Payload` + `Signature`로 나눕니다.
   - `Header`와 `Payload`, `Signatrue`는 점(`.`)으로 구분자로 사용해 연결되어있어 이를 통해 나눕니다.
2. 새로운 서명(Signature)을 생성합니다.
   1. 여기서 `Header`와 `Payload`, 서버만 가지고 있던 비밀번호인 `secret`을 다시 합칩니다.
   2. 암호화 알고리즘을 이용해 암호화합니다.
3. 새로운 서명과 보내진 JWT의 서명을 비교합니다.
   - `Payload`의 내용을 변조했다면, **새로운 서명과 기존 서명의 내용이 달라** JWT가 변조된 JWT인 것을 알 수 있습니다.
   - `Payload`와 `Signature`를 변조했다면, **서버가 아니면 `secret`의 실제 값을 모르기 때문에 제대로 된 `Signature`를 생성할 수 없어** 새로운 서명과 기존 서명의 내용이 달라 JWT가 변조된 JWT인 것을 알 수 있습니다.

## JWT와 암호화 방식

JWT을 안전하게 사용하기 위해서 2가지 방식인 단방향(JWS)와 양방향(JWE)을 지원합니다.
이때의 단방향과 양방향은 사용된 암호화 알고리즘의 종류가 단방향인지 양방향인지를 의미하는 것이 아니라,
암호화 알고리즘을 구분할 때와 같이, **검증할 때 복호화를 안하고 검증하는지, 복호화를 이용하는지**에 따라 나뉩니다.

### 알고리즘

먼저 암호화 알고리즘에 대해 간단히 확인하고 넘어가도록 하겠습니다.
이에 대해 잘 알고 계신다면 넘어가셔도 좋습니다.

![one way encryption](encryption-one_way.png){: .center w="600"}

단방향 암호화 알고리즘
: 단방향(암호화)만 가능한 암호화 방식
: 복호화는 절대로 불가능하게 만든다.
: 해시 함수를 이용해 해시 값을 생성하는 방식이다.
  = 동일한 내용을 암호화하면, 항상 같은 결과가 나온다.
  = 평문(암호화의 대상, 암호화 이전의 데이터)의 내용이 같다면, 암호문(암호화의 대상, 암호화 이후의 데이터)의 내용도 같다.
: 암호화 된 데이터를 검증하려면, 검증할 평문을 암호화 하여 새로운 암호문을 생성한뒤 원래의 암호문과 비교해 같은지 확인한다.
: 예시 암호화 알고리즘으로는 MD5, SHA256 등이 있다.

![two way encryption](encryption-two_way.png){: .center w="600"}

양방향 암호화 알고리즘
: 양방향(암호화, 복호화)가 가능한 암호화 방식
: 암호문을 복호화 할 수 있다.
: **대칭키 방식**과 **비대칭 키 방식** 2가지가 있다.
    - 대칭키
      - 암호화하는 키 = 복호화하는 키
      - 하나의 키로 암호화와 복호화를 다 할 수 있기 때문에, 키를 공개하지 않아야 한다.
    - 비대칭키(공개 키, 비공개 키)
      - 암호화하는 키 != 복호화하는 키
      - 2개의 키를 A와 B라고 할 때, A키로 암호화 하면 B키로만 복호화가 가능하고, B키로 암호화하면 A키로만 복호화가 가능하다.
      - 2개의 키중 하나는 공개키(공개해도 되는 키), 하나는 비밀키(개인키라고도 함, 보호해야하는 키)로 관리한다.
: 예시 암호화 알고리즘
  - 대칭키: DES, AES, SEED, ARIA 등
  - 비대칭키: RSA, DSA, ECC 등
: 같은 암호화 알고리즘을 사용한다고 하더라도, 실제 키는 랜덤성을 가지고 있기 때문에 매번 다른 키가 생성된다.
  양방향 대칭키 알고리즘인 AES를 이용해서 key1과 key2를 만들고, 같은 평문을 각 키로 암호화하면 다른 결과가 나온다.
  그래서 같은 알고리즘을 사용한 키라고 해도, key1로 만든 암호문을 key2로 복호화 할 수 없다.

이제 진짜 암호화 방식에 따른 JWT를 확인해봅시다.

### JWS (JSON Web Signature)

JWS (JSON Web Signature)
: 서명을 이용해 데이터 변조를 방지하고, JWT의 **무결성을 증명**합니다.
: 이때 암호화 알고리즘의 종류(단방향/양방향)에 관계없이 사용할 수 있습니다.
: 중요 포인트는, 서명을 새로 만들고 JWT 의 서명과 비교하는 방식으로 검증한다는 것입니다.
  = **서명을 역으로 해독할 수 없다는 의미**로 단방향 이라고 합니다.

쉽게 말해 위에서 검증을 설명할 때의 방식을 JWS라고 이해하시면 됩니다.
그런데 이때 JWS를 단방향이라고 하는 이유는, (위에서 설명한 것과 같이) 검증할 때 암호화 했던 `Signature`를 복화해서 사용하는 것이 아니라,
검증할 JWT의 Header, Payload를 이용해 새로운 Signatre를 만들어 검증할 JWT의 `Signature`와 비교한다는 점에서 단방향이라고 합니다.

> 단방향 알고리즘을 이용해 비밀번호를 검증 할 때 복호화해서 비교하지 않고 검증 대상의 데이터를 다시 암호화해 비교하는데, 이때의 단방향을 의미한다고 생각하시면 됩니다.

#### 암호화 알고리즘의 차이

단방향 암호화 알고리즘과 양방향 암호화 알고리즘은 분명 암호화 알고리즘의 종류가 달라 차이가 생길텐데, 어떤 차이가 있는걸까요?

- 단방향 암호화 알고리즘
  - 암호화한 `Signature`는 그 누구도 복호화할 수 없지만, 여러 값을 동일한 암호화 알고리즘을 통해 만들고 이 결과가 실제 `Signature`와 같은지 비교하는 방식으로는 확인할 수 있다.
    > 자물쇠의 4자리 비밀번호에 대해서, 0000~9999까지 다 입력해서 비밀번호를 알아내는 방식과 같다고 생각해주시면 됩니다.
  - 다만, 그 계산을 다 해서 `Signature`를 알아내기전에, 토큰의 유효시간이 끝난다.
  - 그렇지만, `secret`의 값이 짧거나 복잡성이 낮아 이러한 계산이 빠르게 된다면 위험할 수 있다.
- 양방향 암호화 대칭키 알고리즘
  - 실제 암호화/복호화에 사용되는 키는 서버만 가지고 있으므로, 같은 알고리즘이더라도 같은 키가 아니면 복호화 할 수 없다.
  - 서버에서도 복호화할 수 있지만, 복호화 하지않고 단방향 방식(=서명을 다시 생성하고 암호화해 결과를 비교하는 방식)으로 검증한다.
- 양방향 암호화 비대칭키 알고리즘

> **암호화와 전자 서명의 차이**
>
{: .prompt-question }

### JWE (JSON Web Encryption)

JWE (JSON Web Encryption)
:

### Nested JWT

Nested JWT
: JWS로 서명한 JWT를 만들고, 그 JWT 전체를 JWE로 암호화하는 방식
---
title: JWT(Json Web Token)
description: JWT가 왜 인증에 사용될  수있을까? 어떻게 사용될까?
author: ggong
date: 2025-03-28 08:27:55 +0900
media_subpath: /assets/img/_posts/study/web
tags:
  - study
  - web
  - jwt
categories:
  - Study
  - Web
references:
  - name: JSON 웹 토큰
    url: https://ko.wikipedia.org/wiki/JSON_%EC%9B%B9_%ED%86%A0%ED%81%B0
    fieldGroup: references
  - url: https://datatracker.ietf.org/doc/html/rfc7519
    name: IETF -RFC 7519
    fieldGroup: references
  - url: https://wikidocs.net/214637#_3
    name: wiki docs - 숏텀 리눅스
    fieldGroup: references
pin: false
---


## JWT란?

JWT(Json Web Token)은 JSON 객체로 인코딩된 클레임 세트를 나타냅니다.

여기까지만 보면 이해가 안되실텐데, 아래의 설명을 통해 알아봅시다.

### JWT의 구성

JWT는 어떻게 생겼는지부터 알아봅시다.

![JWT Structure](jwt-structure.png){: .center w="600"}

#### 헤더(Header)

헤더에는 토큰 자체에 대한 정보를 담고있습니다.
토큰을 암호화할 때 어떤 알고리즘을 썼는지, 토큰의 타입이 무엇인지 등의 정보를 작성합니다.

#### 페이로드(Payload)

페이로드에는 실제 통신에서 주고 받을 때 사용하기 위한 클레임(실제 정보)이 담겨있습니다.
보통은 담고자 하는 정보가 여러개라, 클레임들(Claims)이 담겨있습니다.

클레임(Claim)
: key-value 형태로 된 정보

RFC 7519의 표준에서는 클레임을 3가지 종류로 나눕니다.

- Registered Claim: 표준화 된 클레임으로, 권장되지만 필수는 아닙니다.
  - `iss` (Issuer): 토큰 발급자
  - `sub` (Subject): 토큰 제목 또는 사용자 식별자
  - `aud` (Audience): 토큰 대상자
  - `exp` (Expiration Time): 만료 시간 (Unix Timestamp)
  - `nbf` (Not Before): 토큰 활성 시작 시간
  - `iat` (Issued At): 토큰 발급 시간
  - `jti` (JWT ID): 토큰 고유 식별자
- Public Claim: 커스텀 클레임으로, 공개용 정보 전달을 위해 사용됩니다.
- Private Claim: JWT 토큰을 주고 받는 주체들이 사용할 정보를 의미합니다.

#### 서명(Signature)

서명은 JWT를 사용했을 때 안전함을 증명하는, 무결성을 보장하는 부분입니다.
서명은 앞에 정의했던 헤더, 페이로드, secret 내용을 합친뒤 암호화 합니다.

Secret
: 발급하는 곳에서만 알고있는 정보로, 비밀번호와 같은 내용입니다.

### 서명(Signature): JWT가 안전한 이유

가장 궁금했던 부분입니다.
어떻게 서명을 통해 무결성이 보장되며, 인증 과정에서는 어떻게 서명을 이용해야할지가 가장 궁금했습니다.

#### 검증 과정: 서명의 무결성을 확인하는 법

서버에서 JWT의 무결성은 어떻게 확인할까요?

> JWT의 무결성
> : JWT가 변조되지 않았다는 것을 의미
{: .prompt-info}

**새로운 서명(Header + Payload + secret)을 만들어, 실제 서명과 비교**하여 무결성을 확인합니다.

1. JWT을 `Header` + `Payload` + `Signature`로 나눕니다.
   - `Header`와 `Payload`, `Signatrue`는 점(`.`)으로 구분자로 사용해 연결되어있어 이를 통해 나눕니다.
2. 새로운 서명(Signature)을 생성합니다.
   1. 여기서 `Header`와 `Payload`, 서버만 가지고 있던 비밀번호인 `secret`을 다시 합칩니다.
   2. 암호화 알고리즘을 이용해 암호화합니다.
3. 새로운 서명과 보내진 JWT의 서명을 비교합니다.
   - `Payload`의 내용을 변조했다면, **새로운 서명과 기존 서명의 내용이 달라** JWT가 변조된 JWT인 것을 알 수 있습니다.
   - `Payload`와 `Signature`를 변조했다면, **서버가 아니면 `secret`의 실제 값을 모르기 때문에 제대로 된 `Signature`를 생성할 수 없어** 새로운 서명과 기존 서명의 내용이 달라 JWT가 변조된 JWT인 것을 알 수 있습니다.

## JWT와 암호화

암호화 방식에는 크게 2가지 종류로, 단방향과 양방향이 있습니다.
JWT에는 2가지 방식의 암호화를 지원하는데, 암호화 방식에 따라 서명의 생성 방식이 달라집니다.

### 암호화 방식

먼저, 암호화를 이용한 방식에 대해 알아보기 전에  암호화에 대해 간단히 확인하고 넘어가도록 하겠습니다.

![one way encryption](encryption-one_way.png){: .center w="600"}

단방향 암호화
: 단방향(암호화)만 가능한 암호화 방식
: 복호화는 절대로 불가능하게 만든다.
: 동일한 내용을 암호화하면, 항상 같은 결과가 나온다.
  = 평문(암호화의 대상, 암호화 이전의 데이터)의 내용이 같다면, 암호문(암호화의 대상, 암호화 이후의 데이터)의 내용도 같다.
: 암호화 된 데이터를 검증하려면, 검증할 평문을 암호화 하여 새로운 암호문을 생성한뒤 원래의 암호문과 비교해 같은지 확인한다.
: 예시 암호화 알고리즘으로는 MD5, SHA256 등이 있다.

![two way encryption](encryption-two_way.png){: .center w="600"}

양방향 암호화
: 양방향(암호화, 복호화)가 가능한 암호화 방식
: 암호문을 복호화 할 수 있다.
: **대칭키 방식**과 **비대칭 키 방식** 2가지가 있다.

    - 대칭키: 암호화하는 키 = 복호화하는 키
    - 비대칭키: 암호화하는 키 != 복호화하는 키

: 예시 암호화 알고리즘

  - 대칭키: DES, AES, SEED, ARIA 등
  - 비대칭키: RSA, DSA, ECC 등



### 단방향 암호화를 이용한 방식

단방향 암호화를 이용한 방식은, 위에서 설명했던 방식과 같이 서버에서만 알고 있는 `secret`을 포함하는 방식입니다.

단방향 암호화된 내용은 복호화되지 않기 때문에 비밀번호인 `secret`의 내용을 서버에서만 알고 있고, 이 내용을 포함해 암호화합니다.
그러면 `secret`의 내용이 충분히 길고 복잡하면서, 유출되지 않는다면 JWT의 무결성을 보장할 수 있습니다.

### 양방향 암호화를 이용한 방식

이제 양방향 암호화를 이용한 방식에 대해 알아보겠습니다.

## JWS? JWE?

JWT에 대해 알아보다 보니, JWS와 JWE라는 용어도 같이 보이더라구요.
그래서 이 내용까지 같이 다뤄 보려고 합니다.